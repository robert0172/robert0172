/*
Google Ads Script: Landing Page Change Monitor (MCC Level)

Instructions:
1. Copy this entire script and paste it into your Google Ads MCC-level script editor.
2. In the CONFIG object, replace the 'masterSheetUrl' with the URL of your master Google Spreadsheet.
3. Save the script.
4. Run the script manually to test it, or set up a schedule for automated running.

Master Spreadsheet Structure:
Column A: ACCOUNT ID
Column B: CAMPAIGN LABEL
Column C: EMAIL ADDRESSES (comma-separated for multiple recipients)
Column D: REPORT URL (URL of the Google Spreadsheet for each account's landing page data)
Column E: LastRun in MCCTIME (automatically updated by the script)
Column F: Error message (if any, automatically updated by the script)

This script will:
- Read account data from the master spreadsheet.
- For each account, fetch landing page URLs from the specified report spreadsheet.
- Check the H1 tag and a specific form-control element on each landing page.
- Compare the current content with the previously recorded content.
- Update the report spreadsheet with changes, including:
  - Whether there was a change (yes/no) in column B.
  - The previous H1 tag in column C.
  - The current H1 tag in column D.
  - A description of changes in column E.
  - The last run time in column F.
  - Whether the H1 changed (yes/no) in column G, highlighted in red if changed.
- Send an email alert to the specified addresses with a summary of changes.
- Update the master spreadsheet with the last run time and any error messages.

Note: Make sure you have the necessary permissions to access all accounts and spreadsheets.
The script processes URLs in batches and limits the number of URLs per account to optimize performance.
*/

const CONFIG = {
  masterSheetUrl: "https://docs.google.com/spreadsheets/d/1_G8qinEPKf0rvb8gJzPHIShVtwpqnAWvyWJsU50Qc9o/edit?gid=2026234676#gid=2026234676",
  masterSheetName: "LandingPageChange",
  maxUrlsPerAccount: 100,
  batchSize: 10,
  accountsPerRun: 5,
  queueColumnIndex: 7,
  postcodeColumnIndex: 8  // Dit is kolom H
};

function logMessage(message) {
  Logger.log(message);
}

function main() {
  logMessage("Starting script execution");
  const masterSheet = SpreadsheetApp.openByUrl(CONFIG.masterSheetUrl).getSheetByName(CONFIG.masterSheetName);
  if (!masterSheet) throw new Error("Mastersheet not found");
  
  const accountData = masterSheet.getDataRange().getValues().slice(1);
  
  let processedAccounts = 0;
  
  for (let i = 0; i < accountData.length && processedAccounts < CONFIG.accountsPerRun; i++) {
    const [accountId, campaignLabel, emailAddresses, reportUrl, , , queueStatus] = accountData[i];
    if (!accountId || !campaignLabel || !emailAddresses || !reportUrl) {
      logMessage(`Skipping row ${i + 2} due to missing data`);
      continue;
    }
    
    try {
      logMessage(`Processing account ${accountId}`);
      processAccount(accountId, campaignLabel, reportUrl, emailAddresses);
      masterSheet.getRange(i + 2, 5).setValue(new Date().toISOString());
      masterSheet.getRange(i + 2, 6).setValue("");
      processedAccounts++;
      logMessage(`Finished processing account ${accountId}`);
    } catch (e) {
      logMessage(`Error processing account ${accountId}: ${e.message}`);
      masterSheet.getRange(i + 2, 6).setValue(e.message);
    }
  }
  
  logMessage("Script execution completed");
}

function processAccount(accountId, campaignLabel, reportUrl, emailAddresses) {
  logMessage(`Starting to process account: ${accountId}`);
  const reportSheet = SpreadsheetApp.openByUrl(reportUrl).getActiveSheet();
  const lastRow = Math.max(reportSheet.getLastRow(), 1);
  
  logMessage(`Found ${lastRow - 1} rows of data for account ${accountId}`);
  
  if (lastRow === 1) {
    reportSheet.getRange(1, 1, 1, CONFIG.postcodeColumnIndex).setValues([["Landingpagina", "Change yes or no", "h1 wat het was", "h1 wat het nu is", "Wat voor wijziging", "LastRun", "H1 Changed", "Postcode present"]]);
    return [];
  }

  const results = [];
  
  for (let i = 2; i <= Math.min(lastRow, CONFIG.maxUrlsPerAccount + 1); i++) {
    const row = reportSheet.getRange(i, 1, 1, CONFIG.postcodeColumnIndex).getValues()[0];
    const result = checkUrl(row, i, reportSheet);
    if (result) {
      results.push(result);
    }
    
    if ((i - 1) % CONFIG.batchSize === 0) {
      Utilities.sleep(1000);
    }
  }

  logMessage(`Finished processing account ${accountId}. Found ${results.length} total checks.`);
  sendSummaryEmail(results, accountId, emailAddresses.split(','));
  return results;
}

function checkUrl(row, rowIndex, sheet) {
  const [url, , oldH1Stored, , , lastRun] = row;
  if (!url) {
    logMessage(`No URL found in row ${rowIndex}`);
    return null;
  }

  logMessage(`Checking URL: ${url}`);

  try {
    const response = UrlFetchApp.fetch(url, {muteHttpExceptions: true, followRedirects: true});
    
    if (response.getResponseCode() !== 200) {
      const result = { url, changed: "error", oldH1: oldH1Stored, newH1: oldH1Stored, difference: `Failed with status ${response.getResponseCode()}`, h1Changed: "no", postcodePresent: "no" };
      updateRow(sheet, rowIndex, ["error", oldH1Stored, oldH1Stored, result.difference, new Date().toISOString(), "no", "no"]);
      logMessage(`Error fetching ${url}: ${result.difference}`);
      return result;
    }
    
    const pageHtml = response.getContentText();
    logMessage(`First 200 characters of ${url}: ${pageHtml.substring(0, 200)}`);
    const currentH1 = extractH1(pageHtml);
    const postcodePresent = checkPostcodePresence(pageHtml);
    
    logMessage(`URL: ${url}, H1: ${currentH1}, Postcode present: ${postcodePresent}`);
    
    const h1Changed = (oldH1Stored && oldH1Stored !== currentH1) ? "yes" : "no";
    const changed = h1Changed === "yes" ? "yes" : "no";
    const difference = h1Changed === "yes" 
      ? `H1 changed from "${oldH1Stored}" to "${currentH1}"`
      : `No change in H1.`;

    const result = { url, changed, oldH1: oldH1Stored, newH1: currentH1, difference, h1Changed, postcodePresent };
    
    const updateValues = [
      changed, 
      currentH1,
      currentH1, 
      difference, 
      new Date().toISOString(), 
      h1Changed,
      postcodePresent
    ];
    updateRow(sheet, rowIndex, updateValues);

    if (h1Changed === "yes") {
      logMessage(`H1 changed for ${url}. Old: "${oldH1Stored}", New: "${currentH1}"`);
      sheet.getRange(rowIndex, 7).setFontColor("red").setFontWeight("bold");
    } else {
      logMessage(`No change for ${url}`);
      sheet.getRange(rowIndex, 7).setFontColor("black").setFontWeight("normal");
    }

    if (postcodePresent === "no") {
      sheet.getRange(rowIndex, CONFIG.postcodeColumnIndex).setFontColor("red").setFontWeight("bold");
    } else {
      sheet.getRange(rowIndex, CONFIG.postcodeColumnIndex).setFontColor("black").setFontWeight("normal");
    }

    return result;
  } catch (e) {
    logMessage(`Error checking ${url}: ${e.message}`);
    const result = { url, changed: "error", oldH1: oldH1Stored, newH1: oldH1Stored, difference: e.message, h1Changed: "no", postcodePresent: "no" };
    updateRow(sheet, rowIndex, ["error", oldH1Stored, oldH1Stored, e.message, new Date().toISOString(), "no", "no"]);
    return result;
  }
}

function updateRow(sheet, rowIndex, values) {
  logMessage(`Updating row ${rowIndex} with values: ${JSON.stringify(values)}`);
  sheet.getRange(rowIndex, 2, 1, CONFIG.postcodeColumnIndex - 1).setValues([values]);
}

function extractH1(html) {
  const match = html.match(/<h1[^>]*>(.*?)<\/h1>/i);
  return match ? match[1].replace(/<[^>]+>/g, '').trim() : "Geen H1 gevonden";
}

function checkPostcodePresence(html) {
  logMessage("Checking postcode presence at the top of the page");

  // Neem de eerste 5000 tekens van de HTML (dit zou een groter deel van de bovenkant van de pagina moeten zijn)
  const topOfPage = html.substring(0, 5000);

  // Log de eerste 200 tekens voor debugging
  logMessage("First 200 characters of the page: " + topOfPage.substring(0, 200));

  // Verschillende mogelijke patronen voor postcode-gerelateerde tekst
  const postcodePatterns = [
    /wat is (je|uw) postcode/i,
    /vul (je|uw) postcode in/i,
    /postcode/i,
    /zipcode/i,
    /postal code/i
  ];

  for (let pattern of postcodePatterns) {
    const match = topOfPage.match(pattern);
    if (match) {
      logMessage(`Found postcode-related text: "${match[0]}"`);
      return "yes";
    }
  }

  logMessage("No postcode-related text found at the top of the page");
  return "no";
}

function sendSummaryEmail(results, accountId, emailAddresses) {
  logMessage(`Preparing summary email for account ${accountId}`);
  const subject = `Landing Page Change Monitor Report - Account ${accountId}`;
  
  // Filter resultaten op relevante wijzigingen
  const relevantChanges = results.filter(result => result.h1Changed === "yes" || result.postcodePresent === "no");
  
  let body;
  if (relevantChanges.length > 0) {
    body = `Belangrijke wijzigingen gevonden voor account ${accountId}:\n\n`;
    
    relevantChanges.forEach(result => {
      body += `URL: ${result.url}\n`;
      body += `H1 tag controle: ${result.h1Changed === "yes" ? "Gewijzigd" : "Ongewijzigd"}\n`;
      body += `Postcode aanwezig: ${result.postcodePresent === "yes" ? "Ja" : "Nee"}\n`;
      if (result.h1Changed === "yes") {
        body += `H1 gewijzigd: Oud: "${result.oldH1}", Nieuw: "${result.newH1}"\n`;
      }
      if (result.postcodePresent === "no") {
        body += `Waarschuwing: Postcode vraag niet gevonden bovenaan de pagina\n`;
      }
      body += "--------------------------------------\n";
    });
  } else {
    body = `Alles ziet er goed uit voor account ${accountId}. Er zijn geen H1 tags gewijzigd en de postcode vraag is aanwezig bovenaan de pagina. Je kunt met een opgelucht hart naar je volgende taak gaan.`;
  }

  MailApp.sendEmail(emailAddresses.join(','), subject, body);
  logMessage(`Email sent for account ${accountId}`);
}
